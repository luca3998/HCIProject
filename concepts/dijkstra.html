<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra</title>
</head>
<body>

    
    <!-- 
        Deze pagina wordt een beginnetje gemaakt aan het weergeven van het
        korste pad
     -->

    <svg id="svg" height="95vh" viewBox="0 0 867 685" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule: evenodd; stroke: #000; stroke-linecap: square; clip-rule: evenodd; stroke-miterlimit: 1.5t">
        <path d="m501.6,413l212.4,0l0,-272.6m0,-8l0,-132.4m97.8,499.9l40.5,0l0,17.4l14.4,0l-60.5,0l0,3.8m-267.1,0l-87.8,0l0.1,25.2m324.8,-88.5l0,-11.5m0,-18l0,-15.4l-62.2,0m62.2,-7.9l-2.7,0l0.1,-51l3.1,0m0,-12.1l-3.1,0l0.1,-53l3,0m0,-11.1l-3,0l0.2,-105.3l3.3,0m0.8,-9.5l-64.2,0m64.2,-62.5l-64.2,0m152.7,-100.8l-152.7,0m76.2,100.8l0,-100.8m76.6,100.8l-64.2,0m-12.4,144.1l0,-59.1l-16,0m92.7,-22.5l-60.7,0l0,51.2l-2.2,0m0,12.1l2.2,0l0,51.6l-2.2,0m0,12.4l2.2,0l0,51.5l-2.2,0m0,12.2l2.2,0l0,51l-2.2,0m0,12.4l2.4,0l0,50.8l-2.4,0m0,11.3l62.8,0l0,41.5l-299.5,0m299.5,-41.5l0,-479.5m-246,413l0,53.9m43.8,-53.9l0,53.9m41.2,-53.9l0,53.9m23.1,-53.9l0,66.6m-14.8,-190.5l59.9,0m32.2,1.4l60.7,0m-60.7,-64l60.7,0m-60.7,127.6l60.7,0m-60.7,63.4l60.7,0m-137.9,19.8l48.2,0m-48.2,18.2l47.4,0m-47.4,-8.9l13.2,0m-13.2,17.8l13.2,0m-13.2,9.1l12.4,0l0,2.2m-239.6,-8.7l204,0l0,12.6l35.6,0l0,-4l8.3,0l0,4l26.7,0l0,-13.4m-346.5,98.4l-50.6,0l0,-43.5l50.6,0l0,32.7m-50.6,-14.9l50.6,0m0,-17.7l0,-205.5l71.9,0l0,151.4"style="fill:none;stroke-width:0.8px"/>        
    </svg>

    <input type="number" id="start" value="0">
    <input type="number" id="end" value="0">

    <!-- graph 'import' -->
    <script src="graph.js"></script>
    <script>
        /**
         * Priority Queue implementation
         *
         * code copied from:
         * https://medium.com/@madelinecorman/dijkstras-algorithm-1c6d93c0ea39
         * 
         */
        class PriorityQueue {
            constructor() {
                this.values = [];
            }
            enqueue(value, priority) {
                this.values.push({value, priority});
                this.sort();
            }
            dequeue() {
                return this.values.shift();
            }
            sort() {
                this.values.sort((a, b) => a.priority - b.priority);
            }
        }

        /**
         * Dijkstra's SPF algorithm
         *
         * code slightly tweaked from:
         * https://medium.com/@madelinecorman/dijkstras-algorithm-1c6d93c0ea39
         * 
         */
        function shortestPath(start, finish)
        {
            const vertices = new PriorityQueue();
            const distances = {};
            const previous = {};
            let path = [];
            let smallest;

            for(let vertex in graph.adjacency){
                if(vertex == start){
                    distances[vertex] = 0;
                    vertices.enqueue(vertex, 0);
                } else {
                    distances[vertex] = Infinity;
                    vertices.enqueue(vertex, Infinity);
                }
                previous[vertex] = null;
            }

            while(vertices.values.length){
                smallest = vertices.dequeue().value;
                if(smallest === finish) {
                    while(previous[smallest]){
                        path.unshift(smallest);
                        smallest = previous[smallest];
                    }
                    path.unshift(start);
                    break;
                }
                if(smallest || distances[smallest] !== Infinity){
                    for(let neighbor in graph.adjacency[smallest]){
                        let nextNode = graph.adjacency[smallest][neighbor];
                        let candidate = distances[smallest] + nextNode.weight;
                        let nextNeighbor = nextNode.vertex;
                        if(candidate < distances[nextNeighbor]){
                            distances[nextNeighbor] = candidate;
                            previous[nextNeighbor] = smallest;
                            vertices.enqueue(nextNeighbor, candidate);
                        }
                    }
                }
            }
            return path;
        }




        /**
         * Draw the shortest path on our svg canvas
         * Algorithm will be triggered when one of the input box values changes
         */
        const svg = document.getElementById('svg');

        /* svg namespace */
        const svgns = "http://www.w3.org/2000/svg";

        function drawpath(path)
        {
            /* remove previous paths */
            svg.querySelectorAll('line').forEach(elem => elem.remove());
            
            while(path.length > 1)
            {
                let start = graph.vertices[path.shift()];
                let end = graph.vertices[path[0]];

                let l = document.createElementNS(svgns, "line");
                l.setAttribute("x1", start.x);
                l.setAttribute("y1", start.y);
                l.setAttribute("x2", end.x);
                l.setAttribute("y2", end.y);
                svg.appendChild(l);
            }
        }

        /* some eventListeners to display dijkstra output */
        document.querySelectorAll('input').forEach(element => {
            element.addEventListener('change', event => {
                /* get start and end values */
                let start = document.getElementById('start').value;
                let end = document.getElementById('end').value;

                drawpath(shortestPath(start,end));
            });
        });

    </script>
</body>
</html>